/** * ----------------------------------------------------------------------------+ * Created by: Nathaniel Primo * Filename: HomeScreenViewController.swift * Project Name: Final Project : KidsTale * Program: Software Development and Network Engineering * Course: PROG31632 - Mobile iOS Application Development * Creation Date: 03-08-2020 * Description: Handles the activities that occurs on the Home page * ----------------------------------------------------------------------------+*/import UIKitimport AVFoundationpublic class HomeScreenViewController: HomeController {    /**     * Stores a copy of the UIView that is to be presented when the burger icon is hit    */    @IBOutlet    private var slideoutMenu: UIView?    /**     * Stores the animation that is used to flash the ding icon    */    let dingAnimation: CABasicAnimation = CABasicAnimation(keyPath: "opacity")    /**     * Stores a copy of the UIView for the notification bubble    */    @IBOutlet    private var lblNotificationCount: UILabel?    /**     * Stores a copy of the Segmented control that determines which resources to display    */    @IBOutlet    private var tabResourceType: UITabBar?    /**     * Stores a copy of the Text field that contains the query of the user    */    @IBOutlet    private var textSearch: UITextField?    /**     * Stores the Button that is assigned to the burger icon    */    @IBOutlet    private var burgerIcon: UIButton?    /**     * Stores the endpoint url that is used to grab new books    */    private static let BOOK_API_ENDPOINT: URL = URL(string: "https://api.itbook.store/1.0/new")!    /**     * Stores the location of the menu at each VisibilityState    */    private var slidoutMenuProperties: [VisibilityState: CGRect]?    /**     * Stores a copy of the applications delegate    */    private let sharedDelegate: AppDelegate = UIApplication.shared.delegate as! AppDelegate    public let maxNotifications: Int = 5    private let dingAudio: AVAudioPlayer = try! AVAudioPlayer(data: NSDataAsset(name: "bell", bundle: Bundle.main)!.data)    private var _notificationCount: Int = 0    public var notificationCount: Int {        get {            return _notificationCount        }        set {            if (newValue < 0) {                return            } else if (newValue >= 1) {                dingAudio.currentTime = 0                dingAudio.volume = sharedDelegate.applicationVolume                dingAnimation.fromValue = 0.25                dingAnimation.toValue = 1                dingAnimation.duration = 1                dingAnimation.isRemovedOnCompletion = true;                dingAnimation.keyPath = sharedDelegate.appliedAnimation                dingAudio.play()                lblNotificationCount?.layer.add(dingAnimation, forKey: "dingAnimation")            }            if (newValue > maxNotifications) {                lblNotificationCount?.text = "\(maxNotifications)+"            } else {                lblNotificationCount?.text = String(newValue)            }            lblNotificationCount?.isHidden = newValue == 0            _notificationCount = newValue        }    }    /**     * Grabs books from the API endpoint and adds them to the database    */    public func grabBooks() {        var request = URLRequest(url: HomeScreenViewController.BOOK_API_ENDPOINT)        // Assigns the HTTP method that will be used        request.httpMethod = "GET"        // Adds the appropriate headers to the request        request.addValue("application/json", forHTTPHeaderField: "Accept")        //create dataTask using the session object to send data to the server        let task = URLSession.shared.dataTask(with: request, completionHandler: { data, response, error in            do {                //Retrieves the data from the JSON response                let jsonObject: Array<Dictionary<String, Any>> = (try JSONSerialization.jsonObject(with: data!, options: .mutableContainers)                        as? [String: Any])!["books"] as! Array<Dictionary<String, Any>>                // Adds each book to the database                for book in jsonObject {                    self.sharedDelegate.save(table: Book.self, values: [book["title"], book["subtitle"]])                }                DispatchQueue.main.async {                    self.invalidateTable()                }            } catch let error {                print(error.localizedDescription)            }        })        task.resume()    }    /**     * An event that is fired when the view is loaded into memory    */    override public func viewDidLoad() {        super.viewDidLoad()        dingAudio.numberOfLoops = 1        sharedDelegate.findAll(table: Store.self)        if (sharedDelegate.findAll(table: Book.self).count <= 0) {            grabBooks()        }        lblNotificationCount?.makeCircle()        notificationCount = 0        /**          * Registers a swipe gesture to be fired when the user swipes right on the screen         */        var swipeGesture = UISwipeGestureRecognizer(target: self, action: #selector(changeMenuStateC))        swipeGesture.direction = .right        self.view.addGestureRecognizer(swipeGesture)        /**          * Registers a swipe gesture to be fired when the user swipes left on the screen         */        swipeGesture = UISwipeGestureRecognizer(target: self, action: #selector(changeMenuStateC))        swipeGesture.direction = .left        self.view?.addGestureRecognizer(swipeGesture)        slidoutMenuProperties = [            .hidden: CGRect(x: -1 * (slideoutMenu?.frame.width ?? 0), y: 0, width: (slideoutMenu?.frame.width ?? 0), height: (slideoutMenu?.frame.height ?? 0)),            .visible: slideoutMenu!.frame        ]        /**         * Changes the current state of the pull out menu        */        changeMenuState(isVisible: .hidden, duration: TimeInterval(CGFloat(0)), curve: .linear)        /**         * Creates and introduces the button that will dismiss the pull out menu        */        let exitSlideOut: UIButton = UIButton()        exitSlideOut.frame = CGRect(x: (slideoutMenu?.frame.width ?? 0) - (burgerIcon?.frame.width ?? 0) - (burgerIcon?.frame.minX ?? 0), y: (burgerIcon?.frame.minY ?? 0), width: burgerIcon?.frame.width ?? 0, height: burgerIcon?.frame.height ?? 0)        /**         * Stores the Effect that gives the illusion that the menu is floating        */        let blurEffectView = UIVisualEffectView(effect: UIBlurEffect(style: .dark))        blurEffectView.frame = CGRect(x: slideoutMenu?.frame.width ?? 0, y: 0, width: self.view.frame.width, height: self.view.frame.height)        exitSlideOut.setBackgroundImage(UIImage(named: "close"), for: .normal)        /**         * Register an 'TouchUpInside' event so that the menu disappears        */        exitSlideOut.addTarget(self, action: #selector(hideMenu), for: .touchUpInside)        slideoutMenu?.addSubview(exitSlideOut)        slideoutMenu?.addSubview(blurEffectView)        UITabBarItem.appearance().setTitleTextAttributes([NSAttributedString.Key.font: UIFont.systemFont(ofSize: 24.0)], for: .normal)        tabResourceType?.delegate = self        tabResourceType?.selectedItem = tabResourceType!.items![0]    }    /**     * Handler for when the user presses a tab     * - Parameters:     *      - tabBar: The bar that triggered the event     *      - item: The tab item that was clicked    */    public func tabBar(_ tabBar: UITabBar, didSelect item: UITabBarItem) {        parseResourceType(sender: tabBar)    }    /**     * Parses the correct resource that the user wants to be shown     * - Parameters:     *      - sender: The segmented control that initialized the event    */    @IBAction    public func parseResourceType(sender: UITabBar) {        if (sender.selectedItem?.title == String(describing: Book.self)) {            viewing = Book.self        } else if (sender.selectedItem?.title == String(describing: Store.self)) {            viewing = Store.self        }        textSearch?.text = ""        modifyFilter(textSearch!)    }    /**     * Modifies the search filter that will be used to search through the data     * - Parameters:     *      - sender: The textfield that contains the required search term    */    @IBAction    public func modifyFilter(_ sender: UITextField) {        if (sender.text! == "") {            searchFilter = nil        } else {            searchFilter = { (object: DatabaseItem) in                return object.name.lowercased().contains((sender.text!.lowercased()))            }        }        invalidateTable()    }    /**     * A function created to expose the menu states to Objective-C     * - Parameters:     *      - gesture: TThe gesture that was performed by the user    */    @objc    private func changeMenuStateC(gesture: UISwipeGestureRecognizer) {        switch (gesture.direction) {        case .right:            showMenu(sender: gesture)        case .left:            hideMenu(sender: gesture)        default:            break;        }    }    /**     * An event handler that goal is to show the menu to the user     * - Parameters:     *      - sender: The object that initialized the event    */    @IBAction    private func showMenu(sender: Any?) {        changeMenuState(isVisible: .visible, duration: nil, curve: .linear)    }    /**     * An event handler that goal is to hide th menu from the user    */    @IBAction    private func hideMenu(sender: Any?) {        changeMenuState(isVisible: .hidden, duration: nil, curve: .linear)    }    /**     * Changes the current state of the menu via an animation     * - Parameters:     *      - isVisible: Weather the menu is (VisibilityState.visible) or (VisibilityState.hidden)     *      - duration: The amount of time it should take to complete the animation     *      - curve: The mathematical formula that the animation should follow    */    public func changeMenuState(isVisible: VisibilityState, duration: TimeInterval?, curve: UIView.AnimationCurve) {        let animator = UIViewPropertyAnimator(duration: duration ?? AppDelegate.ANIMATION_DURATION, curve: curve)        /**         * The handler that gets invoked when the animation is complete        */        animator.addCompletion() { position in            /**             *Changes the tag of the menu so that the state can be recorded            */            self.slideoutMenu?.tag = isVisible.rawValue;            self.ignoreResponders()            /**             * Hides the menu once it is no longer on the screen            */            if (isVisible == .visible) {                return            }            self.acknowledgeResponders()            self.slideoutMenu?.isHidden = true        }        /**         * Depending on the VisibilityState that was provide trigger different animations        */        switch (isVisible) {        case .hidden:            animator.addAnimations() {                self.slideoutMenu?.frame = self.slidoutMenuProperties![.hidden]!            }        case .visible:            self.slideoutMenu?.isHidden = false            // Clears the keyboard from the screen            self.resignFirstResponder(nil)            animator.addAnimations() {                self.slideoutMenu?.frame = self.slidoutMenuProperties![.visible]!            }        case .gone:            break        }        animator.startAnimation()    }    /**     * Allows ViewController to perform an unwind segue     * - Parameters:     *      - sender: The object that initialized the event    */    @IBAction    public func unwindToHome(_ sender: UIStoryboardSegue) {        hideMenu(sender: sender)    }}